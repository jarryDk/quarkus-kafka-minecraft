!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("THREE")):"function"==typeof define&&define.amd?define(["THREE"],e):"object"==typeof exports?exports.ENABLE3D=e(require("THREE")):t.ENABLE3D=e(t.THREE)}(self,(t=>(()=>{"use strict";var e={404:(t,e,s)=>{s.r(e),s.d(e,{FIT:()=>n,HEIGHTFIELD_DATA_TYPE:()=>r,TYPE:()=>o,createBoxShape:()=>l,createCapsuleShape:()=>c,createCollisionShapes:()=>a,createConeShape:()=>m,createCylinderShape:()=>h,createHACDShapes:()=>p,createHeightfieldTerrainShape:()=>f,createHullShape:()=>u,createSphereShape:()=>d,createTriMeshShape:()=>g,createVHACDShapes:()=>y,iterateGeometries:()=>w});var i=s(824);const o={BOX:"box",CYLINDER:"cylinder",SPHERE:"sphere",CAPSULE:"capsule",CONE:"cone",HULL:"hull",HACD:"hacd",VHACD:"vhacd",MESH:"mesh",HEIGHTFIELD:"heightfield"},n={ALL:"all",MANUAL:"manual"},r={short:"short",float:"float"},a=function(t,e,s,i,n={}){switch(n.type){case o.BOX:return[l(t,e,i,n)];case o.CYLINDER:return[h(t,e,i,n)];case o.CAPSULE:return[c(t,e,i,n)];case o.CONE:return[m(t,e,i,n)];case o.SPHERE:return[d(t,e,i,n)];case o.HULL:return[u(t,e,i,n)];case o.HACD:return p(t,e,s,i,n);case o.VHACD:return y(t,e,s,i,n);case o.MESH:return[g(t,e,s,i,n)];case o.HEIGHTFIELD:return[f(n)];default:return console.warn(n.type+" is not currently supported"),[]}},l=function(t,e,s,i={}){i.type=o.BOX,b(i),i.fit===n.ALL&&(i.halfExtents=V(C(t,e),i.minHalfExtent,i.maxHalfExtent));const r=new Ammo.btVector3(i.halfExtents.x,i.halfExtents.y,i.halfExtents.z),a=new Ammo.btBoxShape(r);return Ammo.destroy(r),x(a,i,v(s,i)),a},h=function(t,e,s,i={}){i.type=o.CYLINDER,b(i),i.fit===n.ALL&&(i.halfExtents=V(C(t,e),i.minHalfExtent,i.maxHalfExtent));const r=new Ammo.btVector3(i.halfExtents.x,i.halfExtents.y,i.halfExtents.z),a=(()=>{switch(i.cylinderAxis){case"y":return new Ammo.btCylinderShape(r);case"x":return new Ammo.btCylinderShapeX(r);case"z":return new Ammo.btCylinderShapeZ(r)}return null})();return Ammo.destroy(r),x(a,i,v(s,i)),a},c=function(t,e,s,i={}){i.type=o.CAPSULE,b(i),i.fit===n.ALL&&(i.halfExtents=V(C(t,e),i.minHalfExtent,i.maxHalfExtent));const{x:r,y:a,z:l}=i.halfExtents,h=(()=>{switch(i.cylinderAxis){case"y":return new Ammo.btCapsuleShape(Math.max(r,l),2*a);case"x":return new Ammo.btCapsuleShapeX(Math.max(a,l),2*r);case"z":return new Ammo.btCapsuleShapeZ(Math.max(r,a),2*l)}return null})();return x(h,i,v(s,i)),h},m=function(t,e,s,i={}){i.type=o.CONE,b(i),i.fit===n.ALL&&(i.halfExtents=V(C(t,e),i.minHalfExtent,i.maxHalfExtent));const{x:r,y:a,z:l}=i.halfExtents,h=(()=>{switch(i.cylinderAxis){case"y":return new Ammo.btConeShape(Math.max(r,l),2*a);case"x":return new Ammo.btConeShapeX(Math.max(a,l),2*r);case"z":return new Ammo.btConeShapeZ(Math.max(r,a),2*l)}return null})();return x(h,i,v(s,i)),h},d=function(t,e,s,i={}){let r;i.type=o.SPHERE,b(i),r=i.fit!==n.MANUAL||isNaN(i.sphereRadius)?A(t,e,C(t,e)):i.sphereRadius;const a=new Ammo.btSphereShape(r);return x(a,i,v(s,i)),a},u=function(){const t=new i.Vector3,e=new i.Vector3,s=new i.Matrix4;return function(i,r,a,l={}){if(l.type=o.HULL,b(l),l.fit===n.MANUAL)return console.warn("cannot use fit: manual with type: hull"),null;const h=C(i,r),c=new Ammo.btVector3,m=new Ammo.btConvexHullShape;m.setMargin(l.margin),e.addVectors(h.max,h.min).multiplyScalar(.5);let d=0;for(let t=0;t<i.length;t++)d+=i[t].length/3;const u=l.hullMaxVertices||1e5;d>u&&console.warn(`too many vertices for hull shape; sampling ~${u} from ~${d} vertices`);const p=Math.min(1,u/d);for(let o=0;o<i.length;o++){const n=i[o];s.fromArray(r[o]);for(let r=0;r<n.length;r+=3){const a=o===i.length-1&&r===n.length-3;(Math.random()<=p||a)&&(t.set(n[r],n[r+1],n[r+2]).applyMatrix4(s).sub(e),c.setValue(t.x,t.y,t.z),m.addPoint(c,a))}}let y=m;if(m.getNumVertices()>=100){const t=new Ammo.btShapeHull(m);t.buildHull(l.margin),Ammo.destroy(m),y=new Ammo.btConvexHullShape(Ammo.getPointer(t.getVertexPointer()),t.numVertices()),Ammo.destroy(t)}return Ammo.destroy(c),x(y,l,v(a,l)),y}}(),p=function(){const t=new i.Vector3,e=new i.Vector3,s=new i.Matrix4;return function(i,r,a,l,h={}){if(h.type=o.HACD,b(h),h.fit===n.MANUAL)return console.warn("cannot use fit: manual with type: hacd"),[];if(!Ammo.hasOwnProperty("HACD"))return console.warn("HACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const c=C(i,r),m=v(l,h);let d=0,u=0;e.addVectors(c.max,c.min).multiplyScalar(.5);for(let t=0;t<i.length;t++)d+=i[t].length/3,a&&a[t]?u+=a[t].length/3:u+=i[t].length/9;const p=new Ammo.HACD;h.hasOwnProperty("compacityWeight")&&p.SetCompacityWeight(h.compacityWeight),h.hasOwnProperty("volumeWeight")&&p.SetVolumeWeight(h.volumeWeight),h.hasOwnProperty("nClusters")&&p.SetNClusters(h.nClusters),h.hasOwnProperty("nVerticesPerCH")&&p.SetNVerticesPerCH(h.nVerticesPerCH),h.hasOwnProperty("concavity")&&p.SetConcavity(h.concavity);const y=Ammo._malloc(3*d*8),g=Ammo._malloc(3*u*4);p.SetPoints(y),p.SetTriangles(g),p.SetNPoints(d),p.SetNTriangles(u);let f=y/8,w=g/4;for(let o=0;o<i.length;o++){const n=i[o];s.fromArray(r[o]);for(let i=0;i<n.length;i+=3)t.set(n[i+0],n[i+1],n[i+2]).applyMatrix4(s).sub(e),Ammo.HEAPF64[f+0]=t.x,Ammo.HEAPF64[f+1]=t.y,Ammo.HEAPF64[f+2]=t.z,f+=3;if(a[o]){const t=a[o];for(let e=0;e<t.length;e++)Ammo.HEAP32[w]=t[e],w++}else for(let t=0;t<n.length/3;t++)Ammo.HEAP32[w]=t,w++}p.Compute(),Ammo._free(y),Ammo._free(g);const A=p.GetNClusters(),V=[];for(let t=0;t<A;t++){const e=new Ammo.btConvexHullShape;e.setMargin(h.margin);const s=p.GetNPointsCH(t),i=p.GetNTrianglesCH(t),o=Ammo._malloc(3*s*8),n=Ammo._malloc(3*i*4);p.GetCH(t,o,n);const r=o/8;for(let t=0;t<s;t++){const i=new Ammo.btVector3,o=Ammo.HEAPF64[r+3*t+0],n=Ammo.HEAPF64[r+3*t+1],a=Ammo.HEAPF64[r+3*t+2];i.setValue(o,n,a),e.addPoint(i,t===s-1),Ammo.destroy(i)}x(e,h,m),V.push(e)}return V}}(),y=function(){const t=new i.Vector3,e=new i.Vector3,s=new i.Matrix4;return function(i,r,a,l,h={}){if(h.type=o.VHACD,b(h),h.fit===n.MANUAL)return console.warn("cannot use fit: manual with type: vhacd"),[];if(!Ammo.hasOwnProperty("VHACD"))return console.warn("VHACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const c=C(i,r),m=v(l,h);let d=0,u=0;e.addVectors(c.max,c.min).multiplyScalar(.5);for(let t=0;t<i.length;t++)d+=i[t].length/3,a&&a[t]?u+=a[t].length/3:u+=i[t].length/9;const p=new Ammo.VHACD,y=new Ammo.Parameters;h.hasOwnProperty("resolution")&&y.set_m_resolution(h.resolution),h.hasOwnProperty("depth")&&y.set_m_depth(h.depth),h.hasOwnProperty("concavity")&&y.set_m_concavity(h.concavity),h.hasOwnProperty("planeDownsampling")&&y.set_m_planeDownsampling(h.planeDownsampling),h.hasOwnProperty("convexhullDownsampling")&&y.set_m_convexhullDownsampling(h.convexhullDownsampling),h.hasOwnProperty("alpha")&&y.set_m_alpha(h.alpha),h.hasOwnProperty("beta")&&y.set_m_beta(h.beta),h.hasOwnProperty("gamma")&&y.set_m_gamma(h.gamma),h.hasOwnProperty("pca")&&y.set_m_pca(h.pca),h.hasOwnProperty("mode")&&y.set_m_mode(h.mode),h.hasOwnProperty("maxNumVerticesPerCH")&&y.set_m_maxNumVerticesPerCH(h.maxNumVerticesPerCH),h.hasOwnProperty("minVolumePerCH")&&y.set_m_minVolumePerCH(h.minVolumePerCH),h.hasOwnProperty("convexhullApproximation")&&y.set_m_convexhullApproximation(h.convexhullApproximation),h.hasOwnProperty("oclAcceleration")&&y.set_m_oclAcceleration(h.oclAcceleration);const g=Ammo._malloc(3*d*8+3),f=Ammo._malloc(3*u*4);let w=g/8,A=f/4;for(let o=0;o<i.length;o++){const n=i[o];s.fromArray(r[o]);for(let i=0;i<n.length;i+=3)t.set(n[i+0],n[i+1],n[i+2]).applyMatrix4(s).sub(e),Ammo.HEAPF64[w+0]=t.x,Ammo.HEAPF64[w+1]=t.y,Ammo.HEAPF64[w+2]=t.z,w+=3;if(a[o]){const t=a[o];for(let e=0;e<t.length;e++)Ammo.HEAP32[A]=t[e],A++}else for(let t=0;t<n.length/3;t++)Ammo.HEAP32[A]=t,A++}p.Compute(g,3,d,f,3,u,y),Ammo._free(g),Ammo._free(f);const V=p.GetNConvexHulls(),_=[],M=new Ammo.ConvexHull;for(let t=0;t<V;t++){p.GetConvexHull(t,M);const e=M.get_m_nPoints(),s=(M.get_m_points(),new Ammo.btConvexHullShape);s.setMargin(h.margin);for(let t=0;t<e;t++){const i=new Ammo.btVector3,o=M.get_m_points(3*t+0),n=M.get_m_points(3*t+1),r=M.get_m_points(3*t+2);i.setValue(o,n,r),s.addPoint(i,t===e-1),Ammo.destroy(i)}x(s,h,m),_.push(s)}return Ammo.destroy(M),Ammo.destroy(p),_}}(),g=function(){const t=new i.Vector3,e=new i.Vector3,s=new i.Vector3,r=new i.Matrix4;return function(i,a,l,h,c={}){if(c.type=o.MESH,b(c),c.fit===n.MANUAL)return console.warn("cannot use fit: manual with type: mesh"),null;const m=v(h,c),d=new Ammo.btVector3,u=new Ammo.btVector3,p=new Ammo.btVector3,y=new Ammo.btTriangleMesh(!0,!1);for(let o=0;o<i.length;o++){const n=i[o],h=l[o]?l[o]:null;if(r.fromArray(a[o]),h)for(let i=0;i<h.length;i+=3){const o=3*h[i],a=3*h[i+1],l=3*h[i+2];t.set(n[o],n[o+1],n[o+2]).applyMatrix4(r),e.set(n[a],n[a+1],n[a+2]).applyMatrix4(r),s.set(n[l],n[l+1],n[l+2]).applyMatrix4(r),d.setValue(t.x,t.y,t.z),u.setValue(e.x,e.y,e.z),p.setValue(s.x,s.y,s.z),y.addTriangle(d,u,p,!1)}else for(let i=0;i<n.length;i+=9)t.set(n[i+0],n[i+1],n[i+2]).applyMatrix4(r),e.set(n[i+3],n[i+4],n[i+5]).applyMatrix4(r),s.set(n[i+6],n[i+7],n[i+8]).applyMatrix4(r),d.setValue(t.x,t.y,t.z),u.setValue(e.x,e.y,e.z),p.setValue(s.x,s.y,s.z),y.addTriangle(d,u,p,!1)}const g=new Ammo.btVector3(m.x,m.y,m.z);let f;return y.setScaling(g),Ammo.destroy(g),f=c.concave?new Ammo.btBvhTriangleMeshShape(y,!0,!0):new Ammo.btConvexTriangleMeshShape(y,!0),f.resources=[y],Ammo.destroy(d),Ammo.destroy(u),Ammo.destroy(p),x(f,c),f}}(),f=function(t={}){if(b(t),t.fit===n.ALL)return console.warn("cannot use fit: all with type: heightfield"),null;const e=t.heightfieldDistance||1,s=t.heightfieldData||[],i=t.heightScale||0,o=t.hasOwnProperty("upAxis")?t.upAxis:1,r="short"===t.heightDataType?Ammo.PHY_SHORT:Ammo.PHY_FLOAT,a=!t.hasOwnProperty("flipQuadEdges")||t.flipQuadEdges,l=s.length,h=l>0?s[0].length:0,c=Ammo._malloc(l*h*4),m=c/4;let d=Number.POSITIVE_INFINITY,u=Number.NEGATIVE_INFINITY,p=0;for(let t=0;t<l;t++)for(let e=0;e<h;e++){const i=s[t][e];Ammo.HEAPF32[m+p]=i,p++,d=Math.min(d,i),u=Math.max(u,i)}const y=new Ammo.btHeightfieldTerrainShape(h,l,c,i,d,u,o,r,a),g=new Ammo.btVector3(e,1,e);return y.setLocalScaling(g),Ammo.destroy(g),y.heightfieldData=c,x(y,t),y};function b(t){t.type=t.type||o.HULL,t.margin=t.hasOwnProperty("margin")?t.margin:.01}const x=function(t,e,s){},w=function(){const t=new i.Matrix4;return function(e,s,o){parseInt(i.REVISION)>=123?t.copy(e.matrixWorld).invert():t.getInverse(e.matrixWorld);(new i.Vector3).setFromMatrixScale(e.matrixWorld),e.traverse((n=>{const r=new i.Matrix4;n.isMesh&&(s.includeInvisible||n.el&&n.el.object3D.visible||n.visible)&&(n===e?r.identity():(n.updateWorldMatrix(!0),r.multiplyMatrices(t,n.matrixWorld)),o(n.geometry.isBufferGeometry?n.geometry.attributes.position.array:n.geometry.vertices,r.elements,n.geometry.index?n.geometry.index.array:null))}))}}(),v=function(){const t=new i.Matrix4;return function(e,s={}){const o=new i.Vector3(1,1,1);return s.fit===n.ALL&&(t.fromArray(e),o.setFromMatrixScale(t)),o}}(),A=function(){const t=new i.Vector3;return function(e,s,i){let o=0,{x:n,y:r,z:a}=i.getCenter(t);return _(e,s,(t=>{const e=n-t.x,s=r-t.y,i=a-t.z;o=Math.max(o,e*e+s*s+i*i)})),Math.sqrt(o)}}(),V=function(t,e,s){return(new i.Vector3).subVectors(t.max,t.min).multiplyScalar(.5).clampScalar(e,s)},C=function(t,e){const s=new i.Box3;let o=1/0,n=1/0,r=1/0,a=-1/0,l=-1/0,h=-1/0;return s.min.set(0,0,0),s.max.set(0,0,0),_(t,e,(t=>{t.x<o&&(o=t.x),t.y<n&&(n=t.y),t.z<r&&(r=t.z),t.x>a&&(a=t.x),t.y>l&&(l=t.y),t.z>h&&(h=t.z)})),s.min.set(o,n,r),s.max.set(a,l,h),s},_=function(){const t=new i.Vector3,e=new i.Matrix4;return function(s,i,o){for(let n=0;n<s.length;n++){e.fromArray(i[n]);for(let i=0;i<s[n].length;i+=3)t.set(s[n][i],s[n][i+1],s[n][i+2]).applyMatrix4(e),o(t)}}}()},824:e=>{e.exports=t},70:function(t,e,s){var i=this&&this.__spreadArray||function(t,e){for(var s=0,i=e.length,o=t.length;s<i;s++,o++)t[o]=e[s];return t};Object.defineProperty(e,"__esModule",{value:!0}),e.Events=void 0;var o=s(822),n=function(t,e,s){void 0===s&&(s=!1),this.fn=t,this.context=e,this.once=s},r=function(t,e,s,i,o){if("function"!=typeof s)throw new TypeError("The listener must be a function");var r=new n(s,i||t,o);return t._events.has(e)?t._events.get(e).fn?t._events.set(e,[t._events.get(e),r]):t._events.get(e).push(r):(t._events.set(e,r),t._eventsCount++),t},a=function(t,e){0==--t._eventsCount?t._events=new Map:t._events.delete(e)},l=function(){function t(){this._events=new Map,this._eventsCount=0}return Object.defineProperty(t,"VERSION",{get:function(){return o.VERSION},enumerable:!1,configurable:!0}),t.prototype.eventNames=function(){return Array.from(this._events.keys())},t.prototype.listeners=function(t){var e=this._events.get(t);if(!e)return[];if(e.fn)return[e.fn];for(var s=0,i=e.length,o=new Array(i);s<i;s++)o[s]=e[s].fn;return o},t.prototype.listenerCount=function(t){var e=this._events.get(t);return e?e.fn?1:e.length:0},t.prototype.emit=function(t){for(var e,s,o=[],n=1;n<arguments.length;n++)o[n-1]=arguments[n];if(!this._events.has(t))return!1;var r,a=this._events.get(t);if(a.fn)return a.once&&this.removeListener(t,a.fn,void 0,!0),(e=a.fn).call.apply(e,i([a.context],o)),!0;var l=a.length;for(r=0;r<l;r++)a[r].once&&this.removeListener(t,a[r].fn,void 0,!0),(s=a[r].fn).call.apply(s,i([a[r].context],o));return!0},t.prototype.on=function(t,e,s){return r(this,t,e,s,!1)},t.prototype.once=function(t,e,s){return r(this,t,e,s,!0)},t.prototype.removeListener=function(t,e,s,i){if(!this._events.has(t))return this;if(!e)return a(this,t),this;var o=this._events.get(t);if(o.fn)o.fn!==e||i&&!o.once||s&&o.context!==s||a(this,t);else{for(var n=0,r=[],l=o.length;n<l;n++)(o[n].fn!==e||i&&!o[n].once||s&&o[n].context!==s)&&r.push(o[n]);r.length?this._events.set(t,1===r.length?r[0]:r):a(this,t)}return this},t.prototype.removeAllListeners=function(t){return t?this._events.delete(t)&&a(this,t):(this._events=new Map,this._eventsCount=0),this},Object.defineProperty(t.prototype,"off",{get:function(){return this.removeListener},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"addListener",{get:function(){return this.on},enumerable:!1,configurable:!0}),t}();e.Events=l},822:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.VERSION=void 0,e.VERSION="0.0.5"},118:function(t,e,s){var i=this&&this.__spreadArray||function(t,e){for(var s=0,i=e.length,o=t.length;s<i;s++,o++)t[o]=e[s];return t};Object.defineProperty(e,"__esModule",{value:!0}),e.Events=void 0;var o=s(939),n=function(t,e,s){void 0===s&&(s=!1),this.fn=t,this.context=e,this.once=s},r=function(t,e,s,i,o){if("function"!=typeof s)throw new TypeError("The listener must be a function");var r=new n(s,i||t,o);return t._events.has(e)?t._events.get(e).fn?t._events.set(e,[t._events.get(e),r]):t._events.get(e).push(r):(t._events.set(e,r),t._eventsCount++),t},a=function(t,e){0==--t._eventsCount?t._events=new Map:t._events.delete(e)},l=function(){function t(){this._events=new Map,this._eventsCount=0}return Object.defineProperty(t,"VERSION",{get:function(){return o.VERSION},enumerable:!1,configurable:!0}),t.prototype.eventNames=function(){return Array.from(this._events.keys())},t.prototype.listeners=function(t){var e=this._events.get(t);if(!e)return[];if(e.fn)return[e.fn];for(var s=0,i=e.length,o=new Array(i);s<i;s++)o[s]=e[s].fn;return o},t.prototype.listenerCount=function(t){var e=this._events.get(t);return e?e.fn?1:e.length:0},t.prototype.emit=function(t){for(var e,s,o=[],n=1;n<arguments.length;n++)o[n-1]=arguments[n];if(!this._events.has(t))return!1;var r,a=this._events.get(t);if(a.fn)return a.once&&this.removeListener(t,a.fn,void 0,!0),(e=a.fn).call.apply(e,i([a.context],o)),!0;var l=a.length;for(r=0;r<l;r++)a[r].once&&this.removeListener(t,a[r].fn,void 0,!0),(s=a[r].fn).call.apply(s,i([a[r].context],o));return!0},t.prototype.on=function(t,e,s){return r(this,t,e,s,!1)},t.prototype.once=function(t,e,s){return r(this,t,e,s,!0)},t.prototype.removeListener=function(t,e,s,i){if(!this._events.has(t))return this;if(!e)return a(this,t),this;var o=this._events.get(t);if(o.fn)o.fn!==e||i&&!o.once||s&&o.context!==s||a(this,t);else{for(var n=0,r=[],l=o.length;n<l;n++)(o[n].fn!==e||i&&!o[n].once||s&&o[n].context!==s)&&r.push(o[n]);r.length?this._events.set(t,1===r.length?r[0]:r):a(this,t)}return this},t.prototype.removeAllListeners=function(t){return t?this._events.delete(t)&&a(this,t):(this._events=new Map,this._eventsCount=0),this},Object.defineProperty(t.prototype,"off",{get:function(){return this.removeListener},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"addListener",{get:function(){return this.on},enumerable:!1,configurable:!0}),t}();e.Events=l},939:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.VERSION=void 0,e.VERSION="0.0.5"}},s={};function i(t){var o=s[t];if(void 0!==o)return o.exports;var n=s[t]={exports:{}};return e[t].call(n.exports,n,n.exports,i),n.exports}i.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return i.d(e,{a:e}),e},i.d=(t,e)=>{for(var s in e)i.o(e,s)&&!i.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var o={};return(()=>{i.r(o),i.d(o,{AllHitsRaycaster:()=>I,AmmoPhysics:()=>$,Clock:()=>W,ClosestRaycaster:()=>F,ExtendedGroup:()=>c,ExtendedMesh:()=>h,ExtendedObject3D:()=>l,PhysicsLoader:()=>R,Types:()=>t});var t={};i.r(t);const e=new Map,s=(t,s=!1)=>{if(e.has(t)){const s=e.get(t);if(void 0===s)return;if(s>=5)return;e.set(t,s+1)}else e.set(t,1);s?console.error(`%c [enable3d] ${t} `,"background: #222; color: #bada55"):console.warn(`%c [enable3d] ${t} `,"background: #222; color: #bada55")};var n=i(118),r=i(824);const a=class{constructor(t,e){this.physics=t,this.ammo=e,this.ignoreScale=!1,this.isSoftBody=!1,this.offset={x:0,y:0,z:0},this.errors=[],this.checkCollisions=!1,this.breakable=!1,this.fractureImpulse=1,this.didUpdate=!1,this.skipUpdate=!1,this._emitUpdateEvents=!1,this._needUpdate=!1,this.tmpEuler=new r.Euler,this.tmpQuaternion=new r.Quaternion,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtVector3_1=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.eventEmitter=new n.Events,this.name=e.name}destructor(){this.eventEmitter&&this.eventEmitter.removeAllListeners(),Ammo.destroy(this.tmpBtVector3),Ammo.destroy(this.tmpBtVector3_1),Ammo.destroy(this.tmpBtQuaternion),Ammo.destroy(this.ammo.getCollisionShape()),Ammo.destroy(this.ammo)}setupEventEmitter(){void 0===this.eventEmitter&&(this.eventEmitter=new n.Events)}get needUpdate(){return this._needUpdate}set needUpdate(t){!t&&this._needUpdate&&(this.didUpdate=!0),this._needUpdate=t}onUpdateEvent(t,e=!1){this.setupEventEmitter(),this._emitUpdateEvents=!0,e?this.eventEmitter.once("update",(()=>{t()})):this.eventEmitter.on("update",(()=>{t()}))}get on(){return{update:t=>this.onUpdateEvent(t),collision:t=>this.onCollision(t)}}get once(){return{update:t=>this.onUpdateEvent(t,!0)}}onCollision(t){this.checkCollisions=!0,this.physics.collisionEvents.on("collision",(e=>{const{bodies:s,event:i}=e;s[0].name===this.name?t(s[1],i):s[1].name===this.name&&t(s[0],i)}))}transform(){const t=this.physics.worldTransform;this.ammo.getMotionState().getWorldTransform(t)}refresh(){const t=this.physics.worldTransform;this.ammo.getMotionState().setWorldTransform(t)}setRotation(t,e,s){const i=this.tmpEuler.set(t,e,s),o=this.tmpQuaternion.set(0,0,0,1);o.setFromEuler(i),this.tmpBtQuaternion.setValue(0,0,0,1);const n=this.tmpBtQuaternion;n.setValue(o.x,o.y,o.z,o.w);this.physics.worldTransform.setRotation(n)}get rotation(){let t,e,s;const i=this.physics.worldTransform.getRotation();let o=this.tmpQuaternion.set(i.x(),i.y(),i.z(),i.w());o.w>1&&(o=o.normalize());const n=2*Math.acos(o.w),r=Math.sqrt(1-o.w*o.w);return r<.001?(t=o.x,e=o.y,s=o.z):(t=o.x/r,e=o.y/r,s=o.z/r),{x:t*n,y:e*n,z:s*n}}get quaternion(){const t=this.physics.worldTransform.getRotation();return{x:t.x(),y:t.y(),z:t.z(),w:t.w()}}setPosition(t,e,s){this.physics.worldTransform.getOrigin().setValue(t,e,s)}get position(){const t=this.physics.worldTransform;return{x:t.getOrigin().x(),y:t.getOrigin().y(),z:t.getOrigin().z()}}get velocity(){return{x:this.ammo.getLinearVelocity().x(),y:this.ammo.getLinearVelocity().y(),z:this.ammo.getLinearVelocity().z()}}get angularVelocity(){return{x:this.ammo.getAngularVelocity().x(),y:this.ammo.getAngularVelocity().y(),z:this.ammo.getAngularVelocity().z()}}setVelocity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityX(t){this.tmpBtVector3.setValue(t,this.velocity.y,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityY(t){this.tmpBtVector3.setValue(this.velocity.x,t,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityZ(t){this.tmpBtVector3.setValue(this.velocity.x,this.velocity.y,t),this.ammo.setLinearVelocity(this.tmpBtVector3)}setAngularVelocity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityX(t){this.tmpBtVector3.setValue(t,this.angularVelocity.y,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityY(t){this.tmpBtVector3.setValue(this.angularVelocity.x,t,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityZ(t){this.tmpBtVector3.setValue(this.angularVelocity.x,this.angularVelocity.y,t),this.ammo.setAngularVelocity(this.tmpBtVector3)}applyForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceX(t){this.tmpBtVector3.setValue(t,0,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceY(t){this.tmpBtVector3.setValue(0,t,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceZ(t){this.tmpBtVector3.setValue(0,0,t),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralForce(this.tmpBtVector3)}applyCentralImpulse(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralLocalForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralLocalForce(this.tmpBtVector3)}applyImpulse(t,e){this.tmpBtVector3.setValue(t.x||0,t.y||0,t.z||0),this.tmpBtVector3_1.setValue(e.x||0,e.y||0,e.z||0),this.ammo.applyImpulse(this.tmpBtVector3,this.tmpBtVector3_1)}applyLocalTorque(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyLocalTorque(this.tmpBtVector3)}applyTorque(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyTorque(this.tmpBtVector3)}applyTorqueImpulse(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyTorqueImpulse(this.tmpBtVector3)}setCollisionFlags(t){this.ammo.setCollisionFlags(t)}getCollisionFlags(){return this.ammo.getCollisionFlags()}setRestitution(t){this.ammo.setRestitution(t)}setBounciness(t){this.setRestitution(t)}setFriction(t){this.ammo.setFriction(t)}setDamping(t,e){this.ammo.setDamping(t,e)}setGravity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setGravity(this.tmpBtVector3)}setLinearFactor(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setLinearFactor(this.tmpBtVector3)}setAngularFactor(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setAngularFactor(this.tmpBtVector3)}setCcdMotionThreshold(t){this.ammo.setCcdMotionThreshold(t)}setCcdSweptSphereRadius(t){this.ammo.setCcdSweptSphereRadius(t)}};class l extends r.Object3D{constructor(){super(),this.isExtendedObject3D=!0,this.isGroup=!1,this.vector3=new r.Vector3,this.hasBody=!1,this.fragmentDepth=0,this.breakable=!1,this.fractureImpulse=1,this._currentAnimation="",this._animationActions=new Map,this.name=`object-${this.id}`}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}set animationMixer(t){this._animationMixer=t}get animationMixer(){return this._animationMixer||(this._animationMixer=new r.AnimationMixer(this)),this._animationMixer}get anims(){return{current:this._currentAnimation,add:(t,e)=>this._animsAdd(t,e),get:t=>this._animsGet(t),play:(t,e=500,s=!0)=>this._animsPlay(t,e,s),mixer:this.animationMixer}}get animation(){return s('Please use "anims" instead of "animation"'),this.anims}_animsAdd(t,e){this._animationActions.set(t,this.animationMixer.clipAction(e))}_animsGet(t){const e=this._animationActions.get(t);return e||s(`Animation(${t}) not found!`),e}_animsPlay(t,e=500,s=!0){const i=this._animationActions.get(t),o=this._animationActions.get(this._currentAnimation);i&&(i.reset(),o&&(i.crossFadeFrom(o,e/1e3,!0),i.clampWhenFinished=!0),s||i.setLoop(r.LoopOnce,0),i.play()),this._currentAnimation=t}setAction(t){s(`setAction(${t}) is deprecated. Use animation.play(${t}) instead!`)}traverse(t){super.traverse(t)}traverseVisible(t){super.traverseVisible(t)}traverseAncestors(t){super.traverseAncestors(t)}}class h extends r.Mesh{constructor(t,e){super(t,e),this.isExtendedMesh=!0,this.isGroup=!1,this.vector3=new r.Vector3,this.hasBody=!1,this.fragmentDepth=0,this.breakable=!1,this.fractureImpulse=1,this.name=`object-${this.id}`}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}}class c extends r.Group{constructor(){super(),this.isExtendedGroup=!0,this.isMesh=!1,this.hasBody=!1,this.fragmentDepth=0,this.breakable=!1,this.fractureImpulse=1,this.name=`object-${this.id}`}}const m=class{constructor(t,e){this.factory=t,this.addExisting=e}addPlane(t={},e={}){const s=this.factory.add.plane(t,e);return this.addExisting(s,t),s}addSphere(t={},e={}){const s=this.factory.add.sphere(t,e);return this.addExisting(s,t),s}addBox(t={},e={}){const s=this.factory.add.box(t,e);return this.addExisting(s,t),s}addGround(t,e={}){const s=this.factory.add.ground(t,e),i=Object.assign(Object.assign({},t),{mass:0,collisionFlags:1});return this.addExisting(s,i),s}addCylinder(t={},e={}){const s=this.factory.add.cylinder(t,e);return this.addExisting(s,t),s}addCone(t={},e={}){const s=this.factory.add.cone(t,e);return this.addExisting(s,t),s}addTorus(t={},e={}){const s=this.factory.add.torus(t,e);return this.addExisting(s,t),s}addExtrude(t,e={}){const s=this.factory.add.extrude(t,e);return s.translateX(1),this.addExisting(s),s}};class d{constructor(t,e){this.worldTransform=t,this.physicsWorld=e,this.tmpBtVector3=new Ammo.btVector3}toAmmoV3(t,e=0){return new Ammo.btVector3(void 0!==(null==t?void 0:t.x)?t.x:e,void 0!==(null==t?void 0:t.y)?t.y:e,void 0!==(null==t?void 0:t.z)?t.z:e)}get addConstraints(){return{lock:(t,e,s)=>this.lock(t,e,s),fixed:(t,e,s)=>this.fixed(t,e,s),pointToPoint:(t,e,s,i)=>this.pointToPoint(t,e,s,i),hinge:(t,e,s,i)=>this.hinge(t,e,s,i),slider:(t,e,s={},i)=>this.slider(t,e,s,i),spring:(t,e,s={},i)=>this.spring(t,e,s,i),coneTwist:(t,e,s={frameA:{},frameB:{}},i)=>this.coneTwist(t,e,s,i),dof:(t,e,s,i)=>this.dof(t,e,s,i)}}getTransform(t,e,s={x:0,y:0,z:0},i=!1){s=Object.assign({x:0,y:0,z:0},s);const o=new Ammo.btTransform;if(o.setIdentity(),i){const i=(n=t.getWorldTransform().getOrigin(),r=e.getWorldTransform().getOrigin(),a=(n.x()-r.x())/2+s.x,l=(n.y()-r.y())/2+s.y,h=(n.z()-r.z())/2+s.z,new Ammo.btVector3(a,l,h)),o=new Ammo.btTransform;o.setIdentity(),o.setOrigin(i);const c=t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform());return c.op_mul(o),{transformA:c,transformB:o}}o.setOrigin(new Ammo.btVector3(s.x,s.y,s.z));return{transformA:t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform()).op_mul(o),transformB:o};var n,r,a,l,h}lock(t,e,s=!0){const i={x:0,y:0,z:0};return this.dof(t,e,{angularLowerLimit:i,angularUpperLimit:i},s)}fixed(t,e,s=!0){const i=this.getTransform(t.ammo,e.ammo);i.transformA.setRotation(t.ammo.getWorldTransform().getRotation()),i.transformB.setRotation(e.ammo.getWorldTransform().getRotation());const o=new Ammo.btFixedConstraint(t.ammo,e.ammo,i.transformA,i.transformB);return this.physicsWorld.addConstraint(o,s),o}pointToPoint(t,e,s={},i=!0){const{pivotA:o,pivotB:n}=s,r=new Ammo.btVector3((null==o?void 0:o.x)||0,(null==o?void 0:o.y)||0,(null==o?void 0:o.z)||0),a=new Ammo.btVector3((null==n?void 0:n.x)||0,(null==n?void 0:n.y)||0,(null==n?void 0:n.z)||0),l=new Ammo.btPoint2PointConstraint(t.ammo,e.ammo,r,a);return this.physicsWorld.addConstraint(l,i),l}hinge(t,e,s={},i=!0){const{pivotA:o,pivotB:n,axisA:r,axisB:a}=s,l=new Ammo.btVector3((null==o?void 0:o.x)||0,(null==o?void 0:o.y)||0,(null==o?void 0:o.z)||0),h=new Ammo.btVector3((null==n?void 0:n.x)||0,(null==n?void 0:n.y)||0,(null==n?void 0:n.z)||0),c=new Ammo.btVector3((null==r?void 0:r.x)||0,(null==r?void 0:r.y)||0,(null==r?void 0:r.z)||0),m=new Ammo.btVector3((null==a?void 0:a.x)||0,(null==a?void 0:a.y)||0,(null==a?void 0:a.z)||0),d=new Ammo.btHingeConstraint(t.ammo,e.ammo,l,h,c,m,!0);return this.physicsWorld.addConstraint(d,i),d}slider(t,e,s={},i=!0){const o=this.getTransform(t.ammo,e.ammo),{frameA:n={},frameB:r={},linearLowerLimit:a=0,linearUpperLimit:l=0,angularLowerLimit:h=0,angularUpperLimit:c=0}=s,m=o.transformA.getRotation();m.setEulerZYX(n.x||0,n.y||0,n.z||0),o.transformA.setRotation(m);const d=o.transformB.getRotation();d.setEulerZYX(r.x||0,r.y||0,r.z||0),o.transformB.setRotation(d);const u=new Ammo.btSliderConstraint(t.ammo,e.ammo,o.transformA,o.transformB,!0);return u.setLowerLinLimit(a),u.setUpperLinLimit(l),u.setLowerAngLimit(h),u.setUpperAngLimit(c),this.physicsWorld.addConstraint(u,i),u}spring(t,e,s={},i=!0){const{stiffness:o=50,damping:n=.01,angularLock:r=!1,linearLowerLimit:a={},linearUpperLimit:l={},angularLowerLimit:h={},angularUpperLimit:c={},offset:m={},center:d=!1,enableSpring:u=!0}=s,p=Object.assign({x:0,y:0,z:0},m),y=this.getTransform(t.ammo,e.ammo,p,d),g=new Ammo.btGeneric6DofSpringConstraint(t.ammo,e.ammo,y.transformA,y.transformB,!0);this.tmpBtVector3.setValue(a.x||0,a.y||0,a.z||0),g.setLinearLowerLimit(this.tmpBtVector3),this.tmpBtVector3.setValue(l.x||0,l.y||0,l.z||0),g.setLinearUpperLimit(this.tmpBtVector3),r?(this.tmpBtVector3.setValue(0,0,0),g.setAngularLowerLimit(this.tmpBtVector3),g.setAngularUpperLimit(this.tmpBtVector3)):(console.log(h,c),g.setAngularLowerLimit(this.toAmmoV3(h,-Math.PI)),g.setAngularUpperLimit(this.toAmmoV3(c,Math.PI)));for(let t=0;t<3;t++)g.enableSpring(t,u),g.setStiffness(t,o),g.setDamping(t,n);return this.physicsWorld.addConstraint(g,i),g}coneTwist(t,e,s,i=!0){const{frameA:o,frameB:n}=s,r=new Ammo.btTransform;r.setIdentity(),r.getOrigin().setValue((null==o?void 0:o.x)||0,(null==o?void 0:o.y)||0,(null==o?void 0:o.z)||0);const a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue((null==n?void 0:n.x)||0,(null==n?void 0:n.y)||0,(null==n?void 0:n.z)||0);this.getTransform(t.ammo,e.ammo);const l=new Ammo.btConeTwistConstraint(e.ammo,t.ammo,r,a);return l.setAngularOnly(!0),this.physicsWorld.addConstraint(l,i),l}dof(t,e,s={},i=!0){const{offset:o,center:n=!1}=s,r=Object.assign({x:0,y:0,z:0},o),a=this.getTransform(t.ammo,e.ammo,r,n),l=new Ammo.btGeneric6DofConstraint(t.ammo,e.ammo,a.transformA,a.transformB,!0),{linearLowerLimit:h,linearUpperLimit:c,angularLowerLimit:m,angularUpperLimit:d}=s,u=this.toAmmoV3(h),p=this.toAmmoV3(c),y=this.toAmmoV3(m,-Math.PI),g=this.toAmmoV3(d,Math.PI);return l.setLinearLowerLimit(u),l.setLinearUpperLimit(p),l.setAngularLowerLimit(y),l.setAngularUpperLimit(g),Ammo.destroy(u),Ammo.destroy(p),Ammo.destroy(y),Ammo.destroy(g),this.physicsWorld.addConstraint(l,i),l}}var u=i(70);const p=class{constructor(){this._defaultMaterial=new r.MeshLambertMaterial({color:13421772})}get(){return this._defaultMaterial}};class y{constructor(t){this.scene=t,this.isHeadless="headless"===t,this.defaultMaterial=new p}get make(){return{plane:(t={},e={})=>this.makePlane(t,e),box:(t={},e={})=>this.makeBox(t,e),sphere:(t={},e={})=>this.makeSphere(t,e),cylinder:(t={},e={})=>this.makeCylinder(t,e),cone:(t={},e={})=>this.makeCone(t,e),torus:(t={},e={})=>this.makeTorus(t,e),extrude:(t,e={})=>this.makeExtrude(t,e)}}get add(){return{mesh:t=>this.addMesh(t),existing:t=>this.addExisting(t),plane:(t={},e={})=>this.addPlane(t,e),box:(t={},e={})=>this.addBox(t,e),ground:(t,e={})=>this.addGround(t,e),sphere:(t={},e={})=>this.addSphere(t,e),cylinder:(t={},e={})=>this.addCylinder(t,e),cone:(t={},e={})=>this.addCone(t,e),torus:(t={},e={})=>this.addTorus(t,e),extrude:(t,e={})=>this.addExtrude(t,e),material:(t={})=>this.addMaterial(t)}}addExisting(...t){"headless"!==this.scene&&this.scene.add(...t)}addMesh(t){if(Array.isArray(t))for(let e=0;e<t.length;e++)this.addExisting(t[e]);else this.addExisting(t);return this}createMesh(t,e,s){const{x:i=0,y:o=0,z:n=0}=s;let a;switch(!Array.isArray(e)&&e.type){case"LineBasicMaterial":a=new r.Line(t,e);break;case"PointsMaterial":a=new r.Points(t,e);break;default:a=new h(t,e)}return a.position.set(i,o,n),a.castShadow=a.receiveShadow=!0,a}makeExtrude(t,e){const{x:s,y:i,z:o,name:n,shape:a,autoCenter:l=!0,breakable:h=!1,...c}=t,{depth:m=1,bevelEnabled:d=!1}=c,u=new r.ExtrudeBufferGeometry(a,{depth:m,bevelEnabled:d,...c}),p=this.addMaterial(e),y=this.createMesh(u,p,{x:s,y:i,z:o});return l&&y.geometry.center(),y.name=n||`body_id_${y.id}`,y.shape="extrude",y}addExtrude(t,e={}){const s=this.makeExtrude(t,e);return this.addExisting(s),s}makePlane(t,e){const{x:s,y:i,z:o,name:n,breakable:a=!1,...l}=t,h=new r.PlaneBufferGeometry(l.width||1,l.height||1,l.widthSegments||1,l.heightSegments||1),c=this.addMaterial(e);c.side=r.DoubleSide;const m=this.createMesh(h,c,{x:s,y:i,z:o});return m.name=n||`body_id_${m.id}`,m.shape="plane",m}addPlane(t,e){const s=this.makePlane(t,e);return this.addExisting(s),s}makeSphere(t,e){const{x:s,y:i,z:o,name:n,breakable:a=!1,...l}=t,h=new r.SphereBufferGeometry(l.radius||1,l.widthSegments||16,l.heightSegments||12,l.phiStart||void 0,l.phiLength||void 0,l.thetaStart||void 0,l.thetaLength||void 0),c=this.addMaterial(e),m=this.createMesh(h,c,{x:s,y:i,z:o});return m.name=n||`body_id_${m.id}`,m.shape="sphere",m}addSphere(t={},e={}){const s=this.makeSphere(t,e);return this.addExisting(s),s}makeBox(t,e){const{x:s,y:i,z:o,name:n,breakable:a=!1,...l}=t,h=new r.BoxBufferGeometry(l.width||1,l.height||1,l.depth||1,l.widthSegments||void 0,l.heightSegments||void 0,l.depthSegments||void 0),c=this.addMaterial(e),m=this.createMesh(h,c,{x:s,y:i,z:o});return m.name=n||`body_id_${m.id}`,m.shape="box",m}addBox(t={},e={}){const s=this.makeBox(t,e);return this.addExisting(s),s}addGround(t,e={}){const s=this.makeBox(t,e);return s.rotateX(r.MathUtils.degToRad(90)),this.addExisting(s),s}makeCylinder(t={},e={}){const{x:s,y:i,z:o,name:n,breakable:a=!1,...l}=t,h=new r.CylinderBufferGeometry(l.radiusTop||1,l.radiusBottom||1,l.height||1,l.radiusSegments||void 0,l.heightSegments||void 0,l.openEnded||void 0,l.thetaStart||void 0,l.thetaLength||void 0),c=this.addMaterial(e),m=this.createMesh(h,c,{x:s,y:i,z:o});return m.name=n||`body_id_${m.id}`,m.shape="cylinder",m}addCylinder(t={},e={}){const s=this.makeCylinder(t,e);return this.addExisting(s),s}makeCone(t={},e={}){const{x:s,y:i,z:o,name:n,breakable:a=!1,...l}=t,h=new r.ConeBufferGeometry(l.radius||1,l.height||1,l.radiusSegments||8,l.heightSegments||1,l.openEnded||!1,l.thetaStart||0,l.thetaLength||2*Math.PI),c=this.addMaterial(e),m=this.createMesh(h,c,{x:s,y:i,z:o});return m.name=n||`body_id_${m.id}`,m.shape="cone",m}addCone(t={},e={}){const s=this.makeCone(t,e);return this.addExisting(s),s}makeTorus(t={},e={}){const{x:s,y:i,z:o,name:n,breakable:a=!1,...l}=t,h=new r.TorusBufferGeometry(l.radius||void 0,l.tube||void 0,l.radialSegments||void 0,l.tubularSegments||void 0,l.arc||void 0),c=this.addMaterial(e),m=this.createMesh(h,c,{x:s,y:i,z:o});return m.name=n||`body_id_${m.id}`,m.shape="torus",m}addTorus(t={},e={}){const s=this.makeTorus(t,e);return this.addExisting(s),s}addMaterial(t={}){const e=Object.keys(t)[0];let i;if("headless"===this.scene)return this.defaultMaterial.get();switch(e){case"basic":i=new r.MeshBasicMaterial(t.basic);break;case"normal":i=new r.MeshNormalMaterial(t.normal);break;case"standard":i=new r.MeshStandardMaterial(t.standard);break;case"lambert":i=new r.MeshLambertMaterial(t.lambert);break;case"phong":i=new r.MeshPhongMaterial(t.phong);break;case"physical":void 0!==t.physical?i=new r.MeshPhysicalMaterial(t.physical):(s("You need to pass parameters to the physical material. (Fallback to default material)"),i=this.defaultMaterial.get());break;case"toon":i=new r.MeshToonMaterial(t.toon);break;case"line":i=new r.LineBasicMaterial(t.line);break;case"points":i=new r.PointsMaterial(t.points);break;case"custom":i=t.custom||this.defaultMaterial.get();break;default:i=this.defaultMaterial.get()}return i}}class g extends u.Events{addCollider(t,e,s){t.body&&e.body&&(t.body.checkCollisions=!0,e.body.checkCollisions=!0,this.on("collision",(i=>{var o,n;const{bodies:r,event:a}=i;(null===(o=r[0])||void 0===o?void 0:o.name)&&(null===(n=r[1])||void 0===n?void 0:n.name)&&(null==t?void 0:t.name)&&(null==e?void 0:e.name)&&(r[0].name===t.name&&r[1].name===e.name||r[1].name===t.name&&r[0].name===e.name)&&s(a)})))}}const f=1,b=32768;const x=class{constructor(t,e,s={}){this.scene=t,this.world=e,this.options=s,this.debugDrawMode=s.debugDrawMode||f;const i=this.debugDrawMode&b||!1,o=s.maxBufferSize||1e6;this.geometry=new r.BufferGeometry;const n=new Float32Array(3*o),a=new Float32Array(3*o);this.geometry.setAttribute("position",new r.BufferAttribute(n,3).setUsage(r.StaticDrawUsage)),this.geometry.setAttribute("color",new r.BufferAttribute(a,3).setUsage(r.StaticDrawUsage)),this.index=0;const l=new r.LineBasicMaterial({vertexColors:!0,depthTest:!i});this.mesh=new r.LineSegments(this.geometry,l),i&&(this.mesh.renderOrder=999),this.mesh.frustumCulled=!1,this.enabled=!1,this.debugDrawer=new Ammo.DebugDrawer,this.debugDrawer.drawLine=this.drawLine.bind(this),this.debugDrawer.drawContactPoint=this.drawContactPoint.bind(this),this.debugDrawer.reportErrorWarning=this.reportErrorWarning.bind(this),this.debugDrawer.draw3dText=this.draw3dText.bind(this),this.debugDrawer.setDebugMode=this.setDebugMode.bind(this),this.debugDrawer.getDebugMode=this.getDebugMode.bind(this),this.world.setDebugDrawer(this.debugDrawer)}enable(){this.enabled=!0,this.scene.add(this.mesh)}disable(){this.enabled=!1,this.scene.remove(this.mesh)}update(){this.enabled&&(0!=this.index&&(this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0),this.index=0,this.world.debugDrawWorld(),this.geometry.setDrawRange(0,this.index))}drawLine(t,e,s){const i=Ammo.HEAPF32,o=i[(s+0)/4],n=i[(s+4)/4],r=i[(s+8)/4],a=i[(t+0)/4],l=i[(t+4)/4],h=i[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,a,l,h),this.geometry.attributes.color.setXYZ(this.index++,o,n,r);const c=i[(e+0)/4],m=i[(e+4)/4],d=i[(e+8)/4];this.geometry.attributes.position.setXYZ(this.index,c,m,d),this.geometry.attributes.color.setXYZ(this.index++,o,n,r)}drawContactPoint(t,e,s,i,o){const n=Ammo.HEAPF32,r=n[(o+0)/4],a=n[(o+4)/4],l=n[(o+8)/4],h=n[(t+0)/4],c=n[(t+4)/4],m=n[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,h,c,m),this.geometry.attributes.color.setXYZ(this.index++,r,a,l);const d=n[(e+0)/4]*s,u=n[(e+4)/4]*s,p=n[(e+8)/4]*s;this.geometry.attributes.position.setXYZ(this.index,h+d,c+u,m+p),this.geometry.attributes.color.setXYZ(this.index++,r,a,l)}reportErrorWarning(t){Ammo.hasOwnProperty("Pointer_stringify")?console.warn(Ammo.Pointer_stringify(t)):this.warnedOnce||(this.warnedOnce=!0,console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag"))}draw3dText(t,e){console.warn("TODO: draw3dText")}setDebugMode(t){this.debugDrawMode=t}getDebugMode(){return this.debugDrawMode}},w=new r.Vector3,v=new r.Line3,A=new r.Plane,V=new r.Vector3,C=new r.Triangle;class _{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new T,this.unassigned=new T,this.vertices=[]}setFromPoints(t){if(t.length>=4){this.makeEmpty();for(let e=0,s=t.length;e<s;e++)this.vertices.push(new E(t[e]));this.compute()}return this}setFromObject(t){const e=[];return t.updateMatrixWorld(!0),t.traverse((function(t){const s=t.geometry;if(void 0!==s){const i=s.attributes.position;if(void 0!==i)for(let s=0,o=i.count;s<o;s++){const o=new r.Vector3;o.fromBufferAttribute(i,s).applyMatrix4(t.matrixWorld),e.push(o)}}})),this.setFromPoints(e)}containsPoint(t){const e=this.faces;for(let s=0,i=e.length;s<i;s++){if(e[s].distanceToPoint(t)>this.tolerance)return!1}return!0}intersectRay(t,e){const s=this.faces;let i=-1/0,o=1/0;for(let e=0,n=s.length;e<n;e++){const n=s[e],r=n.distanceToPoint(t.origin),a=n.normal.dot(t.direction);if(r>0&&a>=0)return null;const l=0!==a?-r/a:0;if(!(l<=0)&&(a>0?o=Math.min(l,o):i=Math.max(l,i),i>o))return null}return i!==-1/0?t.at(i,e):t.at(o,e),e}intersectsRay(t){return null!==this.intersectRay(t,w)}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(t,e){return t.face=e,null===e.outside?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}removeVertexFromFace(t,e){return t===e.outside&&(null!==t.next&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}removeAllVerticesFromFace(t){if(null!==t.outside){const e=t.outside;let s=t.outside;for(;null!==s.next&&s.next.face===t;)s=s.next;return this.assigned.removeSubList(e,s),e.prev=s.next=null,t.outside=null,e}}deleteFaceVertices(t,e){const s=this.removeAllVerticesFromFace(t);if(void 0!==s)if(void 0===e)this.unassigned.appendChain(s);else{let t=s;do{const s=t.next;e.distanceToPoint(t.point)>this.tolerance?this.addVertexToFace(t,e):this.unassigned.append(t),t=s}while(null!==t)}return this}resolveUnassignedPoints(t){if(!1===this.unassigned.isEmpty()){let e=this.unassigned.first();do{const s=e.next;let i=this.tolerance,o=null;for(let s=0;s<t.length;s++){const n=t[s];if(0===n.mark){const t=n.distanceToPoint(e.point);if(t>i&&(i=t,o=n),i>1e3*this.tolerance)break}}null!==o&&this.addVertexToFace(e,o),e=s}while(null!==e)}return this}computeExtremes(){const t=new r.Vector3,e=new r.Vector3,s=[],i=[];for(let t=0;t<3;t++)s[t]=i[t]=this.vertices[0];t.copy(this.vertices[0].point),e.copy(this.vertices[0].point);for(let o=0,n=this.vertices.length;o<n;o++){const n=this.vertices[o],r=n.point;for(let e=0;e<3;e++)r.getComponent(e)<t.getComponent(e)&&(t.setComponent(e,r.getComponent(e)),s[e]=n);for(let t=0;t<3;t++)r.getComponent(t)>e.getComponent(t)&&(e.setComponent(t,r.getComponent(t)),i[t]=n)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:s,max:i}}computeInitialHull(){const t=this.vertices,e=this.computeExtremes(),s=e.min,i=e.max;let o=0,n=0;for(let t=0;t<3;t++){const e=i[t].point.getComponent(t)-s[t].point.getComponent(t);e>o&&(o=e,n=t)}const r=s[n],a=i[n];let l,h;o=0,v.set(r.point,a.point);for(let e=0,s=this.vertices.length;e<s;e++){const s=t[e];if(s!==r&&s!==a){v.closestPointToPoint(s.point,!0,V);const t=V.distanceToSquared(s.point);t>o&&(o=t,l=s)}}o=-1,A.setFromCoplanarPoints(r.point,a.point,l.point);for(let e=0,s=this.vertices.length;e<s;e++){const s=t[e];if(s!==r&&s!==a&&s!==l){const t=Math.abs(A.distanceToPoint(s.point));t>o&&(o=t,h=s)}}const c=[];if(A.distanceToPoint(h.point)<0){c.push(M.create(r,a,l),M.create(h,a,r),M.create(h,l,a),M.create(h,r,l));for(let t=0;t<3;t++){const e=(t+1)%3;c[t+1].getEdge(2).setTwin(c[0].getEdge(e)),c[t+1].getEdge(1).setTwin(c[e+1].getEdge(0))}}else{c.push(M.create(r,l,a),M.create(h,r,a),M.create(h,a,l),M.create(h,l,r));for(let t=0;t<3;t++){const e=(t+1)%3;c[t+1].getEdge(2).setTwin(c[0].getEdge((3-t)%3)),c[t+1].getEdge(0).setTwin(c[e+1].getEdge(1))}}for(let t=0;t<4;t++)this.faces.push(c[t]);for(let e=0,s=t.length;e<s;e++){const s=t[e];if(s!==r&&s!==a&&s!==l&&s!==h){o=this.tolerance;let t=null;for(let e=0;e<4;e++){const i=this.faces[e].distanceToPoint(s.point);i>o&&(o=i,t=this.faces[e])}null!==t&&this.addVertexToFace(s,t)}}return this}reindexFaces(){const t=[];for(let e=0;e<this.faces.length;e++){const s=this.faces[e];0===s.mark&&t.push(s)}return this.faces=t,this}nextVertexToAdd(){if(!1===this.assigned.isEmpty()){let t,e=0;const s=this.assigned.first().face;let i=s.outside;do{const o=s.distanceToPoint(i.point);o>e&&(e=o,t=i),i=i.next}while(null!==i&&i.face===s);return t}}computeHorizon(t,e,s,i){let o;this.deleteFaceVertices(s),s.mark=1,o=null===e?e=s.getEdge(0):e.next;do{const e=o.twin,s=e.face;0===s.mark&&(s.distanceToPoint(t)>this.tolerance?this.computeHorizon(t,e,s,i):i.push(o)),o=o.next}while(o!==e);return this}addAdjoiningFace(t,e){const s=M.create(t,e.tail(),e.head());return this.faces.push(s),s.getEdge(-1).setTwin(e.twin),s.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let s=null,i=null;for(let o=0;o<e.length;o++){const n=e[o],r=this.addAdjoiningFace(t,n);null===s?s=r:r.next.setTwin(i),this.newFaces.push(r.face),i=r}return s.next.setTwin(i),this}addVertexToHull(t){const e=[];return this.unassigned.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let t;for(this.computeInitialHull();void 0!==(t=this.nextVertexToAdd());)this.addVertexToHull(t);return this.reindexFaces(),this.cleanup(),this}}class M{constructor(){this.normal=new r.Vector3,this.midpoint=new r.Vector3,this.area=0,this.constant=0,this.outside=null,this.mark=0,this.edge=null}static create(t,e,s){const i=new M,o=new S(t,i),n=new S(e,i),r=new S(s,i);return o.next=r.prev=n,n.next=o.prev=r,r.next=n.prev=o,i.edge=o,i.compute()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}compute(){const t=this.edge.tail(),e=this.edge.head(),s=this.edge.next.head();return C.set(t.point,e.point,s.point),C.getNormal(this.normal),C.getMidpoint(this.midpoint),this.area=C.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}}class S{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceTo(t.point):-1}lengthSquared(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}}class E{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}}class T{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,null===e.prev?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,null===e.next?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail;null!==t.next;)t=t.next;return this.tail=t,this}remove(t){return null===t.prev?this.head=t.next:t.prev.next=t.next,null===t.next?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return null===t.prev?this.head=e.next:t.prev.next=e.next,null===e.next?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return null===this.head}}class P extends r.BufferGeometry{constructor(t=[]){super();const e=[],s=[];void 0===_&&console.error("THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on ConvexHull");const i=(new _).setFromPoints(t).faces;for(let t=0;t<i.length;t++){const o=i[t];let n=o.edge;do{const t=n.head().point;e.push(t.x,t.y,t.z),s.push(o.normal.x,o.normal.y,o.normal.z),n=n.next}while(n!==o.edge)}this.setAttribute("position",new r.Float32BufferAttribute(e,3)),this.setAttribute("normal",new r.Float32BufferAttribute(s,3))}}const B=t=>new(window.THREE&&window.THREE.ConvexGeometry?window.THREE.ConvexGeometry:P)(t),O=function(t,e){this.minSizeForBreak=t||1.4,this.smallDelta=e||1e-4,this.tempLine1=new r.Line3,this.tempPlane1=new r.Plane,this.tempPlane2=new r.Plane,this.tempPlane_Cut=new r.Plane,this.tempCM1=new r.Vector3,this.tempCM2=new r.Vector3,this.tempVector3=new r.Vector3,this.tempVector3_2=new r.Vector3,this.tempVector3_3=new r.Vector3,this.tempVector3_P0=new r.Vector3,this.tempVector3_P1=new r.Vector3,this.tempVector3_P2=new r.Vector3,this.tempVector3_N0=new r.Vector3,this.tempVector3_N1=new r.Vector3,this.tempVector3_AB=new r.Vector3,this.tempVector3_CB=new r.Vector3,this.tempResultObjects={object1:null,object2:null},this.segments=[];for(var s=0;s<900;s++)this.segments[s]=!1};var D;O.prototype={constructor:O,prepareBreakableObject:function(t,e,s,i,o){t.geometry.isBufferGeometry||console.error("THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry."),t.userData.ammoPhysicsData={};var n=t.userData.ammoPhysicsData;n.mass=e,n.velocity=s.clone(),n.angularVelocity=i.clone(),n.breakable=o},subdivideByImpact:function(t,e,s,i,o){var n=[],r=this.tempPlane1,a=this.tempPlane2;this.tempVector3.addVectors(e,s),r.setFromCoplanarPoints(e,t.position,this.tempVector3);var l=o+i,h=this;return function o(c,m,d,u){if(Math.random()<.05*u||u>l)n.push(c);else{var p=Math.PI;0===u?(a.normal.copy(r.normal),a.constant=r.constant):u<=i?(p=(d-m)*(.2+.6*Math.random())+m,h.tempVector3_2.copy(t.position).sub(e).applyAxisAngle(s,p).add(e),a.setFromCoplanarPoints(e,h.tempVector3,h.tempVector3_2)):(p=(.5*(1&u)+.2*(2-Math.random()))*Math.PI,h.tempVector3_2.copy(e).sub(c.position).applyAxisAngle(s,p).add(c.position),h.tempVector3_3.copy(s).add(c.position),a.setFromCoplanarPoints(c.position,h.tempVector3_3,h.tempVector3_2)),h.cutByPlane(c,a,h.tempResultObjects);var y=h.tempResultObjects.object1,g=h.tempResultObjects.object2;y&&o(y,m,p,u+1),g&&o(g,p,d,u+1)}}(t,0,2*Math.PI,0),n},cutByPlane:function(t,e,i){var o=t.geometry,n=o.attributes.position.array,a=o.attributes.normal.array,l=n.length/3,h=l/3,c=o.getIndex();function m(t,e){var s=3*t+e;return c?c[s]:s}c&&(h=(c=c.array).length/3);for(var d=[],u=[],p=this.smallDelta,y=l*l,g=0;g<y;g++)this.segments[g]=!1;var f=this.tempVector3_P0,b=this.tempVector3_P1,x=this.tempVector3_N0,w=this.tempVector3_N1;for(g=0;g<h-1;g++){var v=m(g,0),A=m(g,1),V=m(g,2);x.set(a[v],a[v]+1,a[v]+2);for(var C=g+1;C<h;C++){var _=m(C,0),M=m(C,1),S=m(C,2);w.set(a[_],a[_]+1,a[_]+2),1-x.dot(w)<p&&(v===_||v===M||v===S?A===_||A===M||A===S?(this.segments[v*l+A]=!0,this.segments[A*l+v]=!0):(this.segments[V*l+v]=!0,this.segments[v*l+V]=!0):A!==_&&A!==M&&A!==S||(this.segments[V*l+A]=!0,this.segments[A*l+V]=!0))}}var E=this.tempPlane_Cut;t.updateMatrix(),O.transformPlaneToLocalSpace(e,t.matrix,E);for(g=0;g<h;g++)for(var T=m(g,0),P=m(g,1),D=m(g,2),L=0;L<3;L++){var z=0===L?T:1===L?P:D,k=0===L?P:1===L?D:T;if(!this.segments[z*l+k]){this.segments[z*l+k]=!0,this.segments[k*l+z]=!0,f.set(n[3*z],n[3*z+1],n[3*z+2]),b.set(n[3*k],n[3*k+1],n[3*k+2]);var R=0;(H=E.distanceToPoint(f))>p?(R=2,u.push(f.clone())):H<-p?(R=1,d.push(f.clone())):(R=3,d.push(f.clone()),u.push(f.clone()));var H,j=0;if((H=E.distanceToPoint(b))>p?(j=2,u.push(b.clone())):H<-p?(j=1,d.push(b.clone())):(j=3,d.push(b.clone()),u.push(b.clone())),1===R&&2===j||2===R&&1===j){this.tempLine1.start.copy(f),this.tempLine1.end.copy(b);var F=new r.Vector3;if(void 0===(F=E.intersectLine(this.tempLine1,F)))return console.error("Internal error: segment does not intersect plane."),i.segmentedObject1=null,i.segmentedObject2=null,0;d.push(F),u.push(F.clone())}}}var I=.5*t.userData.ammoPhysicsData.mass;this.tempCM1.set(0,0,0);var W=0,N=d.length;if(N>0){for(g=0;g<N;g++)this.tempCM1.add(d[g]);this.tempCM1.divideScalar(N);for(g=0;g<N;g++){(Q=d[g]).sub(this.tempCM1),W=Math.max(W,Q.x,Q.y,Q.z)}this.tempCM1.add(t.position)}this.tempCM2.set(0,0,0);var U=0,G=u.length;if(G>0){for(g=0;g<G;g++)this.tempCM2.add(u[g]);this.tempCM2.divideScalar(G);for(g=0;g<G;g++){var Q;(Q=u[g]).sub(this.tempCM2),U=Math.max(U,Q.x,Q.y,Q.z)}this.tempCM2.add(t.position)}var q=null,$=null,X=0;if(N>4)try{(q=new r.Mesh(B(d),t.material)).position.copy(this.tempCM1),q.quaternion.copy(t.quaternion),q.userData=t.userData,this.prepareBreakableObject(q,I,t.userData.ammoPhysicsData.velocity,t.userData.ammoPhysicsData.angularVelocity,2*W>this.minSizeForBreak),X++}catch(t){s("Error in ConvexObjectBreaker.ts",!0),s(t,!0)}if(G>4)try{($=new r.Mesh(B(u),t.material)).position.copy(this.tempCM2),$.quaternion.copy(t.quaternion),$.userData=t.userData,this.prepareBreakableObject($,I,t.userData.ammoPhysicsData.velocity,t.userData.ammoPhysicsData.angularVelocity,2*U>this.minSizeForBreak),X++}catch(t){s("Error in ConvexObjectBreaker.ts",!0),s(t,!0)}return i.object1=q,i.object2=$,X}},O.transformFreeVector=function(t,e){var s=t.x,i=t.y,o=t.z,n=e.elements;return t.x=n[0]*s+n[4]*i+n[8]*o,t.y=n[1]*s+n[5]*i+n[9]*o,t.z=n[2]*s+n[6]*i+n[10]*o,t},O.transformFreeVectorInverse=function(t,e){var s=t.x,i=t.y,o=t.z,n=e.elements;return t.x=n[0]*s+n[1]*i+n[2]*o,t.y=n[4]*s+n[5]*i+n[6]*o,t.z=n[8]*s+n[9]*i+n[10]*o,t},O.transformTiedVectorInverse=function(t,e){var s=t.x,i=t.y,o=t.z,n=e.elements;return t.x=n[0]*s+n[1]*i+n[2]*o-n[12],t.y=n[4]*s+n[5]*i+n[6]*o-n[13],t.z=n[8]*s+n[9]*i+n[10]*o-n[14],t},O.transformPlaneToLocalSpace=(D=new r.Vector3,function(t,e,s){s.normal.copy(t.normal),s.constant=t.constant;var i=O.transformTiedVectorInverse(t.coplanarPoint(D),e);O.transformFreeVectorInverse(s.normal,e),s.constant=-i.dot(s.normal)});const L=(()=>{try{if("object"==typeof WebAssembly&&"function"==typeof WebAssembly.instantiate){const t=new WebAssembly.Module(Uint8Array.of(0,97,115,109,1,0,0,0));if(t instanceof WebAssembly.Module)return new WebAssembly.Instance(t)instanceof WebAssembly.Instance}}catch(t){t instanceof Error&&console.error(t.message)}return!1})(),z=(t,e)=>{var s=document.createElement("script");s.onload=()=>{e()},s.onerror=()=>{throw new Error(`failed to load ${t}`)},s.async=!0,s.src=t,document.head.appendChild(s)},k=(t,e)=>{z(L?`${t}/ammo.wasm.js`:`${t}/ammo.js`,(()=>e()))},R=(t,e)=>{"undefined"!=typeof window&&(window.__loadPhysics=!0),k(t,(()=>{Ammo().then((()=>{e()}))}))};const H=function(t,e){e.forEach((e=>{Object.getOwnPropertyNames(e.prototype).forEach((s=>{Object.defineProperty(t.prototype,s,Object.getOwnPropertyDescriptor(e.prototype,s)||Object.create(null))}))}))};class j{constructor(t){this.physics=t}setRayFromWorld(t=0,e=0,s=0){this._btRayFrom.setValue(t,e,s)}setRayToWorld(t=0,e=0,s=0){this._btRayTo.setValue(t,e,s)}hasHit(){return this._btRayCallback.hasHit()}rayTest(){void 0!==this._btRayCallback&&Ammo.destroy(this._btRayCallback),this._btRayCallback="closest"===this.type?new Ammo.ClosestRayResultCallback(this._btRayFrom,this._btRayTo):new Ammo.AllHitsRayResultCallback(this._btRayFrom,this._btRayTo),this.physics.physicsWorld.rayTest(this._btRayFrom,this._btRayTo,this._btRayCallback)}destroy(){void 0!==this._btRayFrom&&Ammo.destroy(this._btRayFrom),void 0!==this._btRayTo&&Ammo.destroy(this._btRayTo),void 0!==this._btRayCallback&&Ammo.destroy(this._btRayCallback)}}class F{constructor(t){this.physics=t,this.type="closest",this._btRayFrom=new Ammo.btVector3(0,0,0),this._btRayTo=new Ammo.btVector3(0,0,0)}}class I{constructor(t){this.physics=t,this.type="allHits",this._btRayFrom=new Ammo.btVector3(0,0,0),this._btRayTo=new Ammo.btVector3(0,0,0)}}H(F,[j,class{constructor(t){this.physics=t}getHitPointWorld(){const t=this._btRayCallback.get_m_hitPointWorld();return{x:t.x(),y:t.y(),z:t.z()}}getHitNormalWorld(){const t=this._btRayCallback.get_m_hitNormalWorld();return{x:t.x(),y:t.y(),z:t.z()}}getCollisionObject(){return Ammo.castObject(this._btRayCallback.get_m_collisionObject(),Ammo.btRigidBody).threeObject}}]),H(I,[j,class{constructor(t){this.physics=t}getHitPointsWorld(){const t=this._btRayCallback.get_m_hitPointWorld(),e=[];for(let s=t.size()-1;s>=0;s--){const i=t.at(s);e.push({x:i.x(),y:i.y(),z:i.z()})}return e}getHitPointWorld(){return s("Use getHitPointsWorld() instead of getHitPointWorld() for the AllHitsRayCaster!"),this.getHitPointsWorld()}getHitNormalsWorld(){const t=this._btRayCallback.get_m_hitNormalWorld(),e=[];for(let s=t.size()-1;s>=0;s--){const i=t.at(s);e.push({x:i.x(),y:i.y(),z:i.z()})}return e}getCollisionObjects(){const t=[],e=this._btRayCallback.get_m_collisionObjects();for(let s=e.size()-1;s>=0;s--){const i=Ammo.castObject(e.at(s),Ammo.btRigidBody);t.push(i.threeObject)}return t}}]);class W{constructor(t=!0){this.autoStart=void 0===t||t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=("undefined"==typeof performance?Date:performance).now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=("undefined"==typeof performance?Date:performance).now();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}const{createHACDShapes:N,createHullShape:U,createTriMeshShape:G,createVHACDShapes:Q,iterateGeometries:q}=i(404);class $ extends u.Events{constructor(t,e={}){super(),this.scene=t,this.config=e,this.rigidBodies=[],this.earlierDetectedCollisions=[],this.complexShapes=["plane","hull","hacd","vhacd","convexMesh","concaveMesh"],this.gravity=e.gravity||{x:0,y:-9.81,z:0},this.isHeadless="headless"===t,this.tmpEuler=new r.Euler,this.tmpQuaternion=new r.Quaternion,this.tmpVector3=new r.Vector3,this.tmpVector3a=new r.Vector3,this.tmpMatrix4=new r.Matrix4,this.tmpMatrix4a=new r.Matrix4,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.emptyV3=new r.Vector3,this.impactPoint=new r.Vector3,this.impactNormal=new r.Vector3,"headless"!==t&&(this.defaultMaterial=new p),this.start()}get tmpTrans(){return console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform}set tmpTrans(t){console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform=t}destroy(t){var e;const s=Object.keys(t).includes("body")?t.body:t;if(void 0===(null==s?void 0:s.ammo))return;let i=s.ammo.threeObject;const o=i.name;if(o&&i&&(null===(e=null==i?void 0:i.body)||void 0===e?void 0:e.ammo)){i.body.isSoftBody?this.physicsWorld.removeSoftBody(i.body.ammo):this.physicsWorld.removeRigidBody(i.body.ammo),i.body.destructor(),i.body=void 0,i.hasBody=!1,delete s.ammo.threeObject;for(let t=0;t<this.rigidBodies.length;t++)this.rigidBodies[t].name===o&&(this.rigidBodies.splice(t,1),t--)}"headless"===this.scene&&i&&(i=null)}setup(){if(this.worldTransform=new Ammo.btTransform,"function"==typeof this.config.setupPhysicsWorld?this.physicsWorld=this.config.setupPhysicsWorld():this.physicsWorld=this.setupPhysicsWorld(),"headless"!==this.scene){this.convexBreaker=new O,this.objectsToRemove=[],this.numObjectsToRemove=0;for(let t=0;t<500;t++)this.objectsToRemove[t]=null}this.collisionEvents=new g,this.factory=new y(this.scene),this.shapes=new m(this.factory,((t,e)=>this.addExisting(t,e))),this.constraints=new d(this.worldTransform,this.physicsWorld),"headless"!==this.scene&&(this.debugDrawer=new x(this.scene,this.physicsWorld,{}))}updateDebugger(){"headless"!==this.scene&&this.debugDrawer&&this.debugDrawer.enabled&&this.debugDrawer.update()}setupPhysicsWorld(){const t=this.gravity,{softBodies:e=!1}=this.config;let s;if(!e){const t=new Ammo.btDefaultCollisionConfiguration,e=new Ammo.btCollisionDispatcher(t),i=new Ammo.btDbvtBroadphase,o=new Ammo.btSequentialImpulseConstraintSolver;s=new Ammo.btDiscreteDynamicsWorld(e,i,o,t)}if(e){const t=new Ammo.btSoftBodyRigidBodyCollisionConfiguration,e=new Ammo.btCollisionDispatcher(t),i=new Ammo.btDbvtBroadphase,o=new Ammo.btSequentialImpulseConstraintSolver,n=new Ammo.btDefaultSoftBodySolver;s=new Ammo.btSoftRigidDynamicsWorld(e,i,o,t,n)}return s.setGravity(new Ammo.btVector3(t.x,t.y,t.z)),s}createDebrisFromBreakableObject(t,e){"headless"!==this.scene&&(t.material=e.material,t.shape="hull",t.fragmentDepth=e.fragmentDepth+1,t.name=`${e.name}__DEBRIS_${t.id}`,this.scene.add(t),this.addExisting(t,{autoCenter:!0}),t.body.fractureImpulse=e.body.fractureImpulse,t.body.breakable=!1,setTimeout((()=>{t.body.breakable=!0}),2500))}removeDebris(t){"headless"!==this.scene&&(this.scene.remove(t),this.destroy(t))}update(t){this.updatePhysics(t),this.detectCollisions()}updatePhysics(t){const e=t/1e3;this.physicsWorld.stepSimulation(e,this.config.maxSubSteps||4,this.config.fixedTimeStep||1/60);for(let t=0;t<this.rigidBodies.length;t++){const e=this.rigidBodies[t],s=e.body.ammo.getMotionState();if(s)if(s.getWorldTransform(this.worldTransform),e.body.didUpdate&&(e.body._emitUpdateEvents&&e.body.eventEmitter.emit("update"),e.body.didUpdate=!1),e.body.ammo.isKinematicObject()&&e.body.needUpdate)e.getWorldQuaternion(this.tmpQuaternion),e.getWorldPosition(this.tmpVector3),this.tmpBtVector3.setValue(this.tmpVector3.x,this.tmpVector3.y,this.tmpVector3.z),this.tmpBtQuaternion.setValue(this.tmpQuaternion.x,this.tmpQuaternion.y,this.tmpQuaternion.z,this.tmpQuaternion.w),this.worldTransform.setOrigin(this.tmpBtVector3),this.worldTransform.setRotation(this.tmpBtQuaternion),s.setWorldTransform(this.worldTransform),e.body.needUpdate=!1;else if(e.body.skipUpdate);else if(!e.body.ammo.isStaticObject()){const t=this.worldTransform.getOrigin(),s=this.worldTransform.getRotation(),i=e.body.offset;if(e.body.ignoreScale)this.tmpVector3a.set(e.scale.x,e.scale.y,e.scale.z);else{const t=e.body.ammo.getCollisionShape().getLocalScaling();this.tmpVector3a.set(t.x(),t.y(),t.z())}this.tmpVector3.set(t.x()+i.x,t.y()+i.y,t.z()+i.z),this.tmpQuaternion.set(s.x(),s.y(),s.z(),s.w()),this.tmpMatrix4.compose(this.tmpVector3,this.tmpQuaternion,this.tmpVector3a),e.parent?parseInt(r.REVISION)>=123?this.tmpMatrix4a.copy(e.parent.matrixWorld).invert():this.tmpMatrix4a.getInverse(e.parent.matrixWorld):this.tmpMatrix4a.identity(),this.tmpMatrix4a.multiply(this.tmpMatrix4),this.tmpMatrix4a.decompose(e.position,e.quaternion,e.scale)}}}detectCollisions(){var t,e;const s=[];this.impactPoint.set(0,0,0),this.impactNormal.set(0,0,0);const i=this.physicsWorld.getDispatcher(),o=i.getNumManifolds();for(let n=0;n<o;n++){const o=i.getManifoldByIndexInternal(n),r=o.getNumContacts(),a=Ammo.castObject(o.getBody0(),Ammo.btRigidBody),l=Ammo.castObject(o.getBody1(),Ammo.btRigidBody),h=a.threeObject,c=l.threeObject;if(!h||!c)continue;if(""===a.name&&""===l.name)continue;const m=null===(t=h.body)||void 0===t?void 0:t.checkCollisions,d=null===(e=c.body)||void 0===e?void 0:e.checkCollisions,u=h.body.breakable,p=c.body.breakable,y=h.body.fractureImpulse,g=c.body.fractureImpulse,f=m||d,b=u||p;if(void 0===h.fragmentDepth&&(h.fragmentDepth=0),void 0===c.fragmentDepth&&(c.fragmentDepth=0),!f&&!b)continue;let x=!1,w=0,v="start";for(let t=0;t<r;t++){const e=o.getContactPoint(t);if(e.getDistance()<=0){x=!0;const t=e.getAppliedImpulse(),i=e.get_m_positionWorldOnB(),o=e.get_m_normalWorldOnB();if(m||d){const t=[h.uuid,c.uuid].sort(),e=`${t[0]}__${t[1]}`;this.earlierDetectedCollisions.find((t=>t.combinedName===e))&&(v="collision"),s.find((t=>t.combinedName===e))||(s.push({combinedName:e,collision:!0}),this.collisionEvents.emit("collision",{bodies:[h,c],event:v}))}t>=w&&(w=t,(u||p)&&(this.impactPoint.set(i.x(),i.y(),i.z()),this.impactNormal.set(o.x(),o.y(),o.z())));break}}if(!x)continue;if(!b)continue;const A=2;if(this.emptyV3.set(0,0,0),h.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:u,physicsBody:a},c.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:p,physicsBody:l},u&&w>y&&h.fragmentDepth<A){const t=this.convexBreaker.subdivideByImpact(h,this.impactPoint,this.impactNormal,1,2),e=t.length;for(let s=0;s<e;s++){const e=a.getLinearVelocity(),i=a.getAngularVelocity(),o=t[s];o.userData.ammoPhysicsData.velocity.set(e.x(),e.y(),e.z()),o.userData.ammoPhysicsData.angularVelocity.set(i.x(),i.y(),i.z()),this.createDebrisFromBreakableObject(o,h)}this.objectsToRemove[this.numObjectsToRemove++]=h}if(p&&w>g&&c.fragmentDepth<A){const t=this.convexBreaker.subdivideByImpact(c,this.impactPoint,this.impactNormal,1,2),e=t.length;for(let s=0;s<e;s++){const e=l.getLinearVelocity(),i=l.getAngularVelocity(),o=t[s];o.userData.ammoPhysicsData.velocity.set(e.x(),e.y(),e.z()),o.userData.ammoPhysicsData.angularVelocity.set(i.x(),i.y(),i.z()),this.createDebrisFromBreakableObject(o,c)}this.objectsToRemove[this.numObjectsToRemove++]=c}}for(let t=0;t<this.numObjectsToRemove;t++)this.removeDebris(this.objectsToRemove[t]);this.numObjectsToRemove=0,this.earlierDetectedCollisions.forEach((t=>{const{combinedName:e}=t;if(!s.find((t=>t.combinedName===e))){const t=e.split("__"),s=this.rigidBodies.find((e=>e.uuid===t[0])),i=this.rigidBodies.find((e=>e.uuid===t[1])),o="end";s&&i&&this.collisionEvents.emit("collision",{bodies:[s,i],event:o})}})),this.earlierDetectedCollisions=[...s]}setGravity(t=0,e=-9.8,s=0){this.tmpBtVector3.setValue(t,e,s),this.physicsWorld.setGravity(this.tmpBtVector3)}get debug(){return this.isHeadless?null:{enable:()=>{this.debugDrawer.enable()},mode:(t=1)=>{this.debugDrawer.setDebugMode(t)},disable:()=>{this.debugDrawer.disable()}}}start(){"undefined"!=typeof Ammo?"function"==typeof Ammo?Ammo().then((()=>{this.setup()})):this.setup():s("Are you sure you included ammo.js?")}get add(){return{collider:(t,e,s)=>this.collisionEvents.addCollider(t,e,s),constraints:this.constraints.addConstraints,existing:(t,e)=>this.addExisting(t,e),plane:(t={},e={})=>this.shapes.addPlane(t,e),sphere:(t={},e={})=>this.shapes.addSphere(t,e),ground:(t={},e={})=>this.shapes.addGround(t,e),box:(t={},e={})=>this.shapes.addBox(t,e),cylinder:(t={},e={})=>this.shapes.addCylinder(t,e),cone:(t={},e={})=>this.shapes.addCone(t,e),torus:(t={},e={})=>this.shapes.addTorus(t,e),extrude:(t,e={})=>this.shapes.addExtrude(t,e),raycaster:(t="closest")=>"closest"===t?new F(this):new I(this)}}prepareThreeObjectForCollisionShape(t,e={}){var i,o;const{autoCenter:n=!1}=e,r={width:1,height:1,depth:1,radius:1,radiusTop:1,radiusBottom:1,tube:.4,tubularSegments:6};let a="unknown";const l=(null===(i=t.geometry)||void 0===i?void 0:i.type)||"unknown";/box/i.test(l)?a="box":/cone/i.test(l)?a="cone":/cylinder/i.test(l)?a="cylinder":/extrude/i.test(l)?a="extrude":/plane/i.test(l)?a="plane":/sphere/i.test(l)?a="sphere":/torus/i.test(l)&&(a="torus");let h=Object.assign(Object.assign({},r),null===(o=null==t?void 0:t.geometry)||void 0===o?void 0:o.parameters);return e.shape?(h=Object.assign(Object.assign({},r),e),a=e.shape):t.shape&&(a=t.shape),Object.keys(h).forEach((t=>{void 0===h[t]&&r[t]&&(h[t]=r[t])})),n&&t.geometry.center(),"cylinder"===a&&(h.radius=e.radius||h.radiusTop),"extrude"===a&&(a="hacd"),"mesh"!==a&&"convex"!==a||(a="convexMesh"),"concave"===a&&(a="concaveMesh"),"unknown"===a&&(s(`Shape for ${null==t?void 0:t.name} not recognized! Will fallback to box.`),a="box"),{shape:a,params:h,object:t}}createCollisionShape(t,e,s){const i=(null==s?void 0:s.quaternion)?null==s?void 0:s.quaternion:new r.Quaternion(0,0,0,1),{axis:o="y"}=e,n=new Ammo.btVector3,a=null==s?void 0:s.geometry;s&&(null==a?void 0:a.isGeometry)&&(s.geometry=(new r.BufferGeometry).fromGeometry(a));let l,h={};switch(-1!==this.complexShapes.indexOf(t)&&(h=(t=>{const e=(new r.Matrix4).elements,s=[],i=[],o=[];return q(t,{},((t,e,n)=>{s.push(t),i.push(e),o.push(n)})),{vertices:s,matrices:i,indexes:o,matrixWorld:e}})(s)),t){case"box":n.setValue(e.width/2,e.height/2,e.depth/2),l=new Ammo.btBoxShape(n);break;case"sphere":l=new Ammo.btSphereShape(e.radius);break;case"cylinder":switch(o){case"y":n.setValue(e.radius,e.height/2,e.radius),l=new Ammo.btCylinderShape(n);break;case"x":n.setValue(e.height/2,e.radius,e.radius),l=new Ammo.btCylinderShapeX(n);break;case"z":n.setValue(e.radius,e.radius,e.height/2),l=new Ammo.btCylinderShapeZ(n)}break;case"cone":switch(o){case"y":l=new Ammo.btConeShape(e.radius,e.height);break;case"x":l=new Ammo.btConeShapeX(e.radius,e.height);break;case"z":l=new Ammo.btConeShapeZ(e.radius,e.height)}break;case"capsule":switch(o){case"y":l=new Ammo.btCapsuleShape(e.radius,e.height);break;case"x":l=new Ammo.btCapsuleShapeX(e.radius,e.height);break;case"z":l=new Ammo.btCapsuleShapeZ(e.radius,e.height)}break;case"torus":l=((t,e)=>{const{radius:s=1,tube:i=.4,tubularSegments:o=8}=t,n=Math.PI,r=o,a=Math.sqrt(2*i*i-2*i*i*Math.cos(2*n/r)),l=new Ammo.btVector3(i,n/r+.5*a,i),h=new Ammo.btCylinderShape(l);h.setMargin(.05);const c=new Ammo.btCompoundShape,m=new Ammo.btVector3(0,0,1),d=new Ammo.btVector3(0,s,0),u=new Ammo.btQuaternion(e.x,e.y,e.z,e.w);for(let t=0;t<r;t++){const e=2*t*n/r,s=d.rotate(m,e),i=new Ammo.btTransform;u.setRotation(m,e+Math.PI/2),i.setIdentity(),i.setOrigin(s),i.setRotation(u),c.addChildShape(i,h)}return c})(e,i);break;case"plane":case"convexMesh":l=G(h.vertices,h.matrices,h.indexes,h.matrixWorld,Object.assign(Object.assign({},e),{concave:!1}));break;case"hull":l=U(h.vertices,h.matrices,h.matrixWorld,e);break;case"hacd":l=N(h.vertices,h.matrices,h.indexes,h.matrixWorld,e);break;case"vhacd":l=Q(h.vertices,h.matrices,h.indexes,h.matrixWorld,e);break;case"concaveMesh":l=G(h.vertices,h.matrices,h.indexes,h.matrixWorld,Object.assign(Object.assign({},e),{concave:!0}))}Ammo.destroy(n);const{x:c,y:m,z:d}=e;return(c||m||d)&&(l._compoundOffset={x:c||0,y:m||0,z:d||0}),Array.isArray(l)&&(l=this.mergeCollisionShapesToCompoundShape(l)),l}mergeCollisionShapesToCompoundShape(t){const e=new Ammo.btCompoundShape;return t.forEach((t=>{const{_childOffset:s,_compoundOffset:i}=t;if(s){const{pos:i,quat:o,scale:n,margin:r}=s,a=this.applyPosQuatScaleMargin(t,i,o,n,r);e.addChildShape(a,t)}else if(i){const s=new Ammo.btTransform;s.setIdentity(),s.setOrigin(new Ammo.btVector3(i.x,i.y,i.z)),e.addChildShape(s,t)}else{const s=new Ammo.btTransform;s.setIdentity(),e.addChildShape(s,t)}})),e}addExisting(t,e={}){const{hasBody:i}=t;if(i)return void s(`Object "${t.name}" already has a physical body!`);const o=new r.Vector3,n=new r.Quaternion,a=new r.Vector3;t.getWorldPosition(o),t.getWorldQuaternion(n),t.getWorldScale(a);const l="1"===(e.collisionFlags||0).toString(2).slice(-1),h="1"===(e.collisionFlags||0).toString(2).slice(-2,-1),{shape:c="unknown",compound:m=[],mass:d=(l||h?0:1),collisionFlags:u=0,collisionGroup:p=1,collisionMask:y=-1,offset:g,breakable:f=!1,addChildren:b=!0,margin:x=.01,ignoreScale:w=!1,fractureImpulse:v=1}=e;if(w&&a.set(1,1,1),m.length>=1){const e=m.map((t=>this.createCollisionShape(t.shape,t))),s=this.mergeCollisionShapesToCompoundShape(e),i=this.applyPosQuatScaleMargin(s,o,n,a,x),r=this.collisionShapeToRigidBody(s,i,d,h);return this.addRigidBodyToWorld(t,r,u,p,y,g),t.body.breakable=f,t.body.fractureImpulse=v,void(t.body.ignoreScale=w)}const A=[];if("unknown"!==c||t.isMesh){const s=this.prepareThreeObjectForCollisionShape(t,e),i=this.createCollisionShape(s.shape,s.params,s.object);A.push(i)}if("unknown"===c&&b&&t.children.length>=1&&t.children.forEach((t=>{if(t.isMesh){const e=this.prepareThreeObjectForCollisionShape(t),s=this.createCollisionShape(e.shape,e.params,e.object);s._childOffset={pos:t.position.clone(),quat:t.quaternion.clone(),scale:t.scale.clone(),margin:x},A.push(s)}})),0===A.length){const s=this.prepareThreeObjectForCollisionShape(t,e),i=this.createCollisionShape(s.shape,s.params,s.object);A.push(i)}const V=1===A.length?A[0]:this.mergeCollisionShapesToCompoundShape(A),C=this.applyPosQuatScaleMargin(V,o,n,a,x),_=this.collisionShapeToRigidBody(V,C,d,h);this.addRigidBodyToWorld(t,_,u,p,y,g),t.body.breakable=f,t.body.fractureImpulse=v,t.body.ignoreScale=w}addRigidBodyToWorld(t,e,s,i,o,n){this.rigidBodies.push(t),this.physicsWorld.addRigidBody(e,i,o);const r=Object.values(e)[0];t.name||(t.name=`object-${t.id}`),e.name=t.name,t.body=new a(this,e),t.hasBody=!0,t.ptr=r,e.threeObject=t,n&&(t.body.offset=Object.assign({x:0,y:0,z:0},n)),t.body.setCollisionFlags(s)}applyPosQuatScaleMargin(t,e=new r.Vector3,s=new r.Quaternion,i=new r.Vector3,o=.01){t.setMargin(o);const n=new Ammo.btQuaternion(0,0,0,1);n.setValue(s.x,s.y,s.z,s.w);const a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue(e.x,e.y,e.z),a.setRotation(n),Ammo.destroy(n);const l=new Ammo.btVector3(i.x,i.y,i.z);return t.setLocalScaling(l),Ammo.destroy(l),a}collisionShapeToRigidBody(t,e,s,i){const o=new Ammo.btDefaultMotionState(e),n=new Ammo.btVector3(0,0,0);s>0&&t.calculateLocalInertia(s,n);const r=new Ammo.btRigidBodyConstructionInfo(s,o,t,n),a=new Ammo.btRigidBody(r);return(s>0||i)&&a.setActivationState(4),a}}})(),o})()));